---
title: "Data Storytelling 2 - Decluttering"
output:
  html_document:
    df_print: paged
---
If you've skipped ahead (and not run Part 1), run this code chunk to load the relevant data and plot:

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
source(here("R/init.R"))
```

# Learning Objectives

- Understand why we need to declutter
- Reducing clutter using built in themes
- Removing elements using `theme()`

# Why do we need to declutter our graphs?

- Reduce cognitive load
- Viewer can focus on what matters
- Not every default is useful

# A basic ggplot

We're going to take this basic plot and try to reduce the amount of clutter.

```{r}
my_plot
```

# Part 2: Simplifying your plot

The neat thing about `ggplot2` is that you can modify the plot code by adding *modifiers* with the `+` (plus) sign. 

We're going to take a "paper doll" approach to our plot to modifying it - each *modifier* can be thought of as a set of "clothes" that we dress our plot in. 

The defaults for the plot are decent, but have some distracting elements. We can declutter our plot by removing some of these distracting elements.

Before you move on, discuss on slack:

1) What parts of the plot are distracting from your message?

# Intelligent Defaults: Using Built in Themes

A lot of the simplification can come from built in themes. Adding `theme_minimal()` will remove a lot of the background elements. Try it out and compare it with the above plot.

```{r}
my_plot + theme_minimal()
```

## Removing elements using `theme()`

We can customize our plot even further by adding a `theme()` function to the end of our plot. We'll use this to remove individual elements from the plot.

`theme()` looks very intimidating, because it has lots of different arguments. We'll only look at a few of these:

- `axis.title`, `axis.title.x` and `axis.title.y` (The labels for the axes)
- `panel.grid` (grid lines)
- `legend.position` (Placing the legend, including removing it)

How will we remove these elements? We will specify an element called `element_blank()` to these arguments. What is this? Think of it as a special placeholder that says we don't want to see this element.

Let's try simplifying our plot by removing the x-axis text. By context, the label `crime_yearmonth` isn't that helpful.

```{r}
my_plot + 
  theme(axis.title.x = element_blank())

```

Try removing the legend. Hmm, it is more simplified, but we have lost all the information about the categories! We can add that information back with the use of color in the next section.

```{r}
my_plot + 
  theme(legend.position = "none")
```

Try removing the gridlines. Is that helpful?

```{r}
my_plot + 
  theme(panel.grid = element_blank())
```

## Your turn

Play with different combinations of these different `theme()` statements to customize your plot. If you want to remove a line, you can put a `#` in front of that line. That will make it a comment and that line of code won't run.

```{r}
my_plot +
  theme_minimal() + 
  theme(axis.title.x = element_blank()) + 
  theme(panel.grid = element_blank()) + 
  theme(legend.position = "none")
```

# Part 3: Annotating

Another way we can guide people through our visualization is by using **annotations**, which can be very helpful. 

1) Changing Titles and Axis Titles using `labs()`
2) Adding reference lines using `geom_hline()` and `geom_vline()`
3) Annotating the plot directly using `annotate()`

Before you move on, discuss: 

```{r}
my_plot +
  labs(title = "Is it better to burn out than fade away?",x="Season Number", y="Average Rating")
```

## Adding a Reference Line

Using `geom_hline()` to show the average value across a time period can provide a useful reference for viewers:

```{r}
my_plot + 
  geom_hline(yintercept = 7.8, lty=3)
```

## Adding text annotations

Adding text annotations directly to the graph can be extremely helpful, especially if there is a point of interest you want users to look at. (For adding text information per data point, look at `geom_text()` and `geom_repel()` from the `ggrepel` package).

The first argument to `annotate()` is "text", and it takes `x` and `y` arguments to determine the position of our annotation. Our actual text goes in the `label` argument. If we want to add a line break in our text, we can add `\n`.

Try adjusting the `y` argument for `annotate()` to get the annotation more centered around the mean line. 

```{r}
my_plot + 
  geom_hline(yintercept = 7.8, lty=3) +
  annotate("text", x = 2, y=10, label="Mean\n Rating") 
```

### Part 3: Your Turn

Experiment with the following modifications to the graph. If you have time, cut and paste the modifications you decided on in part 2 to your graph.

If there's a show that you want to highlight, try adding an annotation to highlight it. Or try adding an annotation at `Roseanne`'s lowest rating!

```{r}
my_plot + 
  geom_hline(yintercept = 8, lty=3) +
  annotate("text", x = 2, y=8, label="Mean\n Rating") +
  annotate("text", x = 7, y=8.5, label = "The Walking\n Dead (ugh)") +
  labs(title = "Is it better to burn out than fade away?",x="Season Number", y="Average Rating")
```

# Part 4: Working with Color/Contrast

## Highlighting part of your data

What if we only want to highlight one group in the data?

Before you move on, discuss:

1) What is your finding?
2) What part/group of the data were you emphasizing?
3) What colors did you use?

We can manually color a single group in our data through a two step process. For example, if we want to highlight "Motor Vehicle Theft" but not the others we can:

1. make a "dummy" variable called `motor_theft` by recoding the `offense_category` variable to have `Y` for `Motor Vehicle Theft` and `N` for the other categories
2. manually color the lines using `scale_color_manual()` by specifying a values argument.

### Using a dummy variable in our dataset

We can add a new variable using what is called a `mutate()` function. It lets us calculate a new variable, based on the other values of the variable. If you've used Excel's `IF()` function, it's very similar in terms of the syntax. We first provide a condition:

```
ifelse(offense_category == "Motor Vehicle Theft", 
                  yes = "Y", no = "N")
```

The `ifelse()` function can be read:

> If the value for `offense_category` is "Motor Vehicle Theft" THEN recode that value as "Y",
> If it doesn't equal "Motor Vehicle Theft", THEN recode that value as "N"

Run the code below and explore the table a little bit to confirm that "Motor Vehicle Theft" crimes are coded as `Y` in our new variable, `motor_theft`:

```{r}
crime_stat <- crime_data_stat %>% 
  mutate(motor_theft = 
           ifelse(offense_category == "Motor Vehicle Theft", 
                  yes = "Y", no = "N")) 

DT::datatable(crime_stat)
```

## Using `scale_color_manual()` to color our new variable

Now we have our new variable called `motor_theft`, we need to map the `Y` and `N` values to actual colors. We can do this by using the `scale_color_manual()` function, which lets us map values to specific colors by using the `values` argument.

```{r}
#put your final plot here
library(tidyverse)

  ggplot(crime_stat, aes(x = crime_yearmonth, y= count, group=offense_category, color = motor_theft)) + 
   geom_line() + scale_color_manual(values=c("Y"="blue", "N"="grey"))
```

### Try out mapping colors

Try using different colors to contrast the `motor_theft` line. A small list of color names in R can be found here: https://www.r-graph-gallery.com/42-colors-names.html

If you want all of the color names (there are a lot of them!) you can run this code block:

```{r}
colors()
```


```{r}
library(tidyverse)

my_new_plot <-   ggplot(crime_stat, aes(x = crime_yearmonth, y= count, group=offense_category, color = motor_theft)) + 
   geom_line()

my_new_plot + 
  scale_color_manual(values=c("Y"="blue", "N"="grey"))
```


## Put it all together!

Cut and paste all your modifiers and make your final figure below!

```{r eval=FALSE}
my_new_plot +
  
```


## Optional: Highlighting a subset of the data

What if we wanted to highlight a specific time period in our dataset? We can actually subset the data

We want to specify this criteria in our `filter()` statement:

```{r}
crime_subset <- crime_stat %>%
  filter(crime_yearmonth >= "2017-01-01") %>%
  filter(crime_yearmonth <= "2018-01-01")
```

Now we can use this dataset to highlight this portion of the data:

```{r}
  crime_stat %>% ggplot(aes(x = crime_yearmonth, y= count, group=offense_category)) + 
   geom_line(color = "grey") +
   geom_line(data = crime_subset, color = "blue") +
  geom_vline(xintercept = as.Date("2017-01-01"), color="blue", lty=3) +
  geom_vline(xintercept = as.Date("2018-01-01"), color="blue", lty=3) +
  annotate("text", x=as.Date("2017-06-01"), y= 1200, label= "Time period\n of Interest", color="blue") +
  labs(title = "Motor Thefts in 2017-2018 are flat") +
  theme_minimal() +
    theme(axis.title.x = element_blank()) +
  theme(panel.grid = element_blank()) 
```

What if we wanted to show only the "Motor Vehicle Theft" category in blue? Then we can add an additional `filter()` statement in our subset:

```{r fig.width = 5, fig.height=5}
crime_subset <- crime_stat %>%
  filter(crime_yearmonth >= "2017-01-01") %>%
  filter(crime_yearmonth <= "2018-01-01") %>%
  filter(offense_category == 
                    "Motor Vehicle Theft")

  crime_stat %>% ggplot(aes(x = crime_yearmonth, y= count, group=offense_category)) + 
   geom_line(color = "grey") +
   geom_line(data = crime_subset, color = "blue") +
  geom_vline(xintercept = as.Date("2017-01-01"), color="blue", lty=3) +
  geom_vline(xintercept = as.Date("2018-01-01"), color="blue", lty=3) +
  annotate("text", x=as.Date("2017-06-01"), y= 1200, label= "Time period\n of Interest") +
  labs(title = "Crimes in 2017-2018 are flat") +
  theme_minimal() +
    theme(axis.title.x = element_blank()) +
  theme(panel.grid = element_blank()) 

```

# Saving High Quality Plots

We can use `ggsave()` to save our plot.

```{r eval=FALSE}
ggsave("timeplot.pdf")
```

# Interactive plots: using `plotly`

`plotly` is a JavaScript library that allows you to make plots that are interactive on a webpage. Mousing over traces can reveal what's called a `tooltip` - additional information about that datapoint that you can specify

Once the plots are built, they don't require R to run, so they can be hosted on a site for static webpages.

```{r}
library(plotly)

crime_stat <- crime_data_stat %>% 
  mutate(motor_theft = 
           ifelse(offense_category == 
                    "Motor Vehicle Theft", "Y", "N"),
         mean_count=mean(count)) 

mean_c <- crime_stat$mean_count[1]

my_plot <- crime_stat %>%  
  ungroup(offense_category) %>%
  ggplot(aes(x = crime_yearmonth, y= count, 
             group=offense_category, color = motor_theft)) + 
   geom_line() + 
  scale_color_manual(values=c("Y"="blue", "N"="grey")) +
  theme_minimal() +
  theme(panel.grid = element_blank()) +
  theme(legend.position = "none") +
  labs(title = "Auto Crimes are Levelling Off\n Compared to Other Crimes",x="Year/Month", y="Number of Crimes") +
  annotate("text", x = as.Date("2016-03-01"), y=600, label="Mean\n Crime") + 
  geom_hline(yintercept = mean_c, lty=3)

ggplotly(my_plot)
```


# Finishing up

Try